/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Wizard.gltf --transform 
Files: Wizard.gltf [3.3MB] > C:\Repos\Kuji\kujidev.github.io\public\models\Wizard-transformed.glb [436.09KB] (87%)
*/

import React, { useEffect, useRef, useMemo } from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { usePlayerState } from '@/hooks/usePlayerState'
import CastingCircle from '@/components/CastingCircle'
import ShieldEffect from '@/components/ShieldEffect'
import ManaShield from '@/components/ManaShield'
import ArcaneTrail from '@/components/ArcaneTrail'
import { getElementForAction, ELEMENTS } from '@/config/actions'
import * as THREE from 'three'

const GLOW_MATERIALS = {}
Object.values(ELEMENTS).forEach(element => {
  GLOW_MATERIALS[element.id] = new THREE.MeshStandardMaterial({
    color: element.glow,
    emissive: element.glow,
    emissiveIntensity: 4,
    toneMapped: false,
  })
})

export function Model(props) {
  const group = React.useRef()
  const wizardRef = React.useRef()
  const staffMaterialRef = useRef(null)
  const originalStaffMaterialRef = useRef(null)
  const originalMaterialsRef = useRef(new Map()) // Store all original materials
  const currentActionRef = useRef(null)
  const recastCounterRef = useRef(0) // Track recasts to trigger animation reset
  const { scene, animations: gltfAnimations } = useGLTF('/models/Wizard-transformed.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { actions } = useAnimations(gltfAnimations, clone)
  const { animation, state, activeAction, setCastProgress, dispatchAction, tryRecast, STATES, buffs } = usePlayerState()

  useEffect(() => {
    wizardRef.current = clone
  }, [clone])

  useEffect(() => {
    clone.traverse((child) => {
      if (!child.isMesh) return
      
      originalMaterialsRef.current.set(child, child.material.clone())
      
      if (child.name.includes('Wizard_Staff')) {
        staffMaterialRef.current = child
        originalStaffMaterialRef.current = child.material.clone()
      }
    })
  }, [clone])

  const isArcaneRush = state === STATES.MOVING && activeAction === 'skill_3'
  
  useEffect(() => {
    if (isArcaneRush) {
      clone.traverse((child) => {
        if (child.isMesh) {
          child.material = new THREE.MeshBasicMaterial({
            color: new THREE.Color(0.35, 0.19, 0.55),
            transparent: true,
            opacity: 0.7,
          })
        }
      })
    } else {
      clone.traverse((child) => {
        if (child.isMesh && originalMaterialsRef.current.has(child)) {
          child.material = originalMaterialsRef.current.get(child).clone()
        }
      })
    }
  }, [isArcaneRush, clone])

  useEffect(() => {
    if (!staffMaterialRef.current) return

    const element = activeAction ? getElementForAction(activeAction) : null
    
    if (element && state !== STATES.IDLE) {
      staffMaterialRef.current.material = GLOW_MATERIALS[element.id] || originalStaffMaterialRef.current
    } else {
      staffMaterialRef.current.material = originalStaffMaterialRef.current
    }
  }, [state, activeAction, STATES])

  useEffect(() => {
    const currentAction = actions?.[animation]
    if (!currentAction) return

    currentActionRef.current = currentAction

    Object.values(actions).forEach((action) => {
      if (action !== currentAction) action?.fadeOut(0.2)
    })

    const isCastingOrAttacking = state === STATES.CASTING || state === STATES.ATTACKING
    if (isCastingOrAttacking) {
      currentAction.setLoop(THREE.LoopOnce, 1)
      currentAction.clampWhenFinished = true
      setCastProgress(0)
    } else {
      currentAction.setLoop(THREE.LoopRepeat)
    }

    currentAction.reset().fadeIn(0.2).play()
  }, [animation, actions, state, activeAction, STATES, setCastProgress])

  useFrame(() => {
    const action = currentActionRef.current
    if (!action) return

    if (state === STATES.CASTING || state === STATES.ATTACKING) {
      const duration = action.getClip().duration
      const time = Math.min(action.time, duration)
      const progress = time / duration
      setCastProgress(progress)

      if (progress >= 0.99) {
        // tryRecast returns true if recasting (key held + has mana)
        if (tryRecast()) {
          action.reset().play()
          recastCounterRef.current++
        } else {
          dispatchAction('FINISH')
        }
      }
    }
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <primitive object={clone} />
      <CastingCircle position={[0, 0.02, 0]} />
      <ShieldEffect position={[0, 1.5, 0]} />
      <ManaShield position={[0, 1.5, 0]} />
      <ArcaneTrail wizardRef={wizardRef} />
    </group>
  )
}

useGLTF.preload('/models/Wizard-transformed.glb')
